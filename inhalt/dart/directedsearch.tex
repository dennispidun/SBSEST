\section{Directed Search Algorithmus}
Der directed Search Algorithmus unterstützt DART bei der Findung von Eingabevektoren. Ähnlich wie bei der dynamischen
Generierung von Testdaten wird das Programm zunächst mit zufälligen Werten gestartet \cite{godefroid2005dart, korel1990dynamic}.
DART zielt hierbei darauf ab, Unterstützung für die zufällige Generierung von Testdaten zu bieten. Somit soll mithilfe
des Suchprozesses die Generierung in die richtige Richtung gelenkt werden können. Dabei sollen die verschiedenen Eingabevektoren
ein möglichst großes Spektrum an verschiedenen Pfaden aufweisen können. Für jede Ausführung wird nun ein neuer Inputvektor
gebildert. Wie bereits erläutert, ist der Inputvektor entscheidend für die Reihenfolge der Statements, die ausgeführt werden.
Dieser Inputvektor kann dann für die nächsten Iterationen genutzt werden.

Die Instrumentalisierung des Programms beginnt also mit der Initialisierung des Inputvektors und des Stacks. Dieser
beruht auf zufälligen Daten. Anschließend wird für die \textit{Symbolic Execution} ein \textit{Symbolic Memory} angelegt.
Dieses wird immer dann mit neuen Informationen versorgt, wenn es ein Assignment Statement erkennt \cite{godefroid2005dart}.
Hier wird somit der Ausdruck \(e\) mithilfe des Memory Mapping und des Symbolic Memory symbolisch ausgewertet. Zeitgleich
wird für dieses Statement der konkrete Wert berechnet und im Memory Mapping gespeichert \cite{godefroid2005dart}. Da wir
wissen, dass nach einem Assignment Statement ein neues Statement folgen muss, wird der Zeiger für das Statement um eins
verschoben. Dieser Zeiger zeigt also nun auf das nächste verfügbare Statement. Im Falle eines Conditional Statements wird
der Ausdruck \(e\) sowohl konkret als auch symbolisch evaluiert \cite{godefroid2005dart}. Sollte die konkrete Evaluierung
den Wert \textit{wahr} zurückgeben, wird zum Speicher der \textit{Path Constraints} der symbolisch evaluierte Wert vom
Ausdruck \(e\) hinzugefügt \cite{godefroid2005dart}. Außerdem wird der Stack aktualisiert, sodass dieser über den Wert
der symbolischen Evaluierung Bescheid weiß. Im Falle, dass die konkrete Evaluierung den Wert \textit{falsch} zurück gibt,
wird zum Speicher der \textit{Path Constraints} der negierte symbolisch evaluierte Wert vom Ausdruck \(e\) hinzugefügt
\cite{godefroid2005dart}. Der Stack wird nun mit der Information aktualisiert, dass der konkret evaluierte Wert \textit{falsch}
betrug \cite{godefroid2005dart}. Außerdem wird das nächste zu evaluierende Statement auf das nächste verfügbare Statement
gesetzt \cite{godefroid2005dart}. Sollte das Statement \textit{Abort} beinhalten, bricht DART an der Stelle ab und wirft
eine Exception, welche wiederum vom Testdriver aufgefangen werden kann. Im Falle eines \textit{Halt} Statements wird
der \textit{Path Constraint Solver} aufgerufen. Dies bedeutet, dass das Programm auf normalem Weg beendet wurde, ohne
dass ein Fehler gefunden wurde.

\subsection{Path Constraint Solver}
Der Path Constraint Solver sucht nach einem geeigneten Eingabewert, welcher für den gesamten Ausdruck \textit{wahr} als
Rückgabewert liefert.


Als Fortsetzung dieses Kapitels soll also beschrieben werden, wie DART diese Pfadbeschränkungen auflöst und schlussendlich
zu neuen Eingabewerten gelangt.

